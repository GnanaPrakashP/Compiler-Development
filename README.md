# Compiler-Development
I have developed a compiler for a language similar to C programming language. This compiler supports recursive functions, structures, classes and objects, inheritance, and polymorphism.

An informal specification of the source programming language - https://silcnitc.github.io/expl.html

The specification for an extension of the primary source language with support for object-oriented programming - https://silcnitc.github.io/oexpl-specification.html

This project is made into two parts,
Part 1 supports functions, structures, classes, and objects.
Part 2 supports inheritance and polymorphism.

Overview of the project
A compiler must generate a binary executable file that can be loaded and executed by an operating system running on a target machine. Normally, an OS system installation comes with an interface specification, explaining how binary executable files must be formatted to run on the system. This interface is called the Application Binary Interface (ABI).
The ABI is dependent on both the OS and the machine architecture. The ABI for this project is that of the Experimental Operating System (ExpOS) running on the Experimental String Machine [XSM].
The ABI specification - https://silcnitc.github.io/abi.html (The simulator allows the target program to contain machine instructions in mnemonic form, avoiding translation to binary format).

A compiler takes a source language program as input and produces an executable target file formatted according to the requirements laid down by the ABI. Of course, the semantics of the program must be preserved by the translation process.
The main intellectual complexity in understanding a compiler is that its inputs and outputs are programs – that is, a compiler's input data is a (source language) program and its output is a (target language) program. The task is to systematically map each construct in the source program to semantically equivalent constructs in the target language.
A textbook approach to compilation logically divides the process into several parts. The lexical elements of the input program are identified during a lexical analysis phase. The software tool LEX is used in this phase. The lexemes identified by the lexical analysis phase are passed to the next phase – called the syntax analysis phase - which checks the program against syntax errors. If the program is free of syntax errors, the next conceptual stage called the semantic analysis phase, checks for type and scope errors in the program. Once a program is found to be free of syntax and semantic errors, an intermediate representation of the source program called the abstract syntax tree representation is generated by the compiler. (In practice, syntax analysis, semantic analysis, and abstract syntax tree construction happen together. The syntax directed translation scheme provided by the software tool YACC is used for completing these phases.) The sequence of phases starting with the lexical analysis of the source program to the generation of abstract syntax tree representation is called the front end of the compiler.
